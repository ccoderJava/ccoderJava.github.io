(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{496:function(a,t,r){"use strict";r.r(t);var s=r(9),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"java创建线程方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java创建线程方式"}},[a._v("#")]),a._v(" Java创建线程方式")]),a._v(" "),r("h2",{attrs:{id:"线程池核心参数、创建方式、拒绝策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程池核心参数、创建方式、拒绝策略"}},[a._v("#")]),a._v(" 线程池核心参数、创建方式、拒绝策略")]),a._v(" "),r("h2",{attrs:{id:"线程各状态生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程各状态生命周期"}},[a._v("#")]),a._v(" 线程各状态生命周期")]),a._v(" "),r("h2",{attrs:{id:"线程池复用原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程池复用原理"}},[a._v("#")]),a._v(" 线程池复用原理")]),a._v(" "),r("h2",{attrs:{id:"synchronized和lock锁区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized和lock锁区别"}},[a._v("#")]),a._v(" Synchronized和Lock锁区别")]),a._v(" "),r("h2",{attrs:{id:"countdownlatch和cyclicbarrier"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch和cyclicbarrier"}},[a._v("#")]),a._v(" CountDownLatch和CyclicBarrier")]),a._v(" "),r("h2",{attrs:{id:"reentrantlock源码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock源码"}},[a._v("#")]),a._v(" ReentrantLock源码")]),a._v(" "),r("h2",{attrs:{id:"锁的分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁的分类"}},[a._v("#")]),a._v(" 锁的分类")]),a._v(" "),r("blockquote",[r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/oheg2010/article/details/89850181",target:"_blank",rel:"noopener noreferrer"}},[a._v("锁的分类"),r("OutboundLink")],1)])])]),a._v(" "),r("h3",{attrs:{id:"悲观锁-和-乐观锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁-和-乐观锁"}},[a._v("#")]),a._v(" 悲观锁 和 乐观锁")]),a._v(" "),r("p",[r("strong",[a._v("悲观锁")]),a._v("：在进入同步方法的时候都会获取当前同步锁对象，直到退出同步方法时才会释放同步锁对象。如果有线程A和线程B,同他们都会访问obj对象的同步方法。当线程A获取到obj对象的同步锁，在执行某些方法的时候，这时候线程B企图获取 obj对象的同步锁就会失败，这个时候必须等待，直到线程A释放掉 obj对象的同步锁，线程B才能执行obj的同步方法\njava中的悲观锁是synchronized，AQS框架下的锁则是先尝试CAS乐观锁去获取，获取不到，才会转为悲观锁，如RetreenLock")]),a._v(" "),r("p",[r("strong",[a._v("乐观锁")]),a._v("：乐观锁是一种读多写少，遇到并发写的性能可能会变低，每次去拿数据的时候都认为不会修改，所以不会上锁。java乐观锁基本都通过CAS操作实现的，cas是一种依赖系统指令集实现原子操作，比较当前变量值与预期值是否一样,如果相同就使用系统原语进行更新。")]),a._v(" "),r("ul",[r("li",[a._v("独占锁和共享锁")])]),a._v(" "),r("h2",{attrs:{id:"可重入锁-和-不可重入锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁-和-不可重入锁"}},[a._v("#")]),a._v(" 可重入锁 和 不可重入锁")]),a._v(" "),r("h2",{attrs:{id:"公平锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#公平锁"}},[a._v("#")]),a._v(" 公平锁")]),a._v(" "),r("h2",{attrs:{id:"synchronized锁的优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized锁的优化"}},[a._v("#")]),a._v(" Synchronized锁的优化")]),a._v(" "),r("h2",{attrs:{id:"轻量锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#轻量锁"}},[a._v("#")]),a._v(" 轻量锁")]),a._v(" "),r("h2",{attrs:{id:"偏向锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁")]),a._v(" "),r("h2",{attrs:{id:"轻量锁-和-偏向锁的状态转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#轻量锁-和-偏向锁的状态转换"}},[a._v("#")]),a._v(" 轻量锁 和 偏向锁的状态转换")])])}),[],!1,null,null,null);t.default=e.exports}}]);