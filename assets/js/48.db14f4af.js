(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{499:function(a,t,r){"use strict";r.r(t);var s=r(9),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"java"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[a._v("#")]),a._v(" Java")]),a._v(" "),r("h3",{attrs:{id:"hashmap扩容机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap扩容机制"}},[a._v("#")]),a._v(" HashMap扩容机制")]),a._v(" "),r("h3",{attrs:{id:"hashmap无法保证线程安全的原因"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashmap无法保证线程安全的原因"}},[a._v("#")]),a._v(" HashMap无法保证线程安全的原因")]),a._v(" "),r("h3",{attrs:{id:"avl树和红黑树比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#avl树和红黑树比较"}},[a._v("#")]),a._v(" AVL树和红黑树比较")]),a._v(" "),r("h3",{attrs:{id:"concurrenthashmap-如何保证线程安全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-如何保证线程安全"}},[a._v("#")]),a._v(" ConcurrentHashMap 如何保证线程安全")]),a._v(" "),r("ul",[r("li",[a._v("CAS Synchronized")]),a._v(" "),r("li",[a._v("Segment ReentrantLock")])]),a._v(" "),r("h3",{attrs:{id:"优先队列priorityqueue的原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优先队列priorityqueue的原理"}},[a._v("#")]),a._v(" 优先队列PriorityQueue的原理")]),a._v(" "),r("h3",{attrs:{id:"linkedtransferqueue和synchronousqueue区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#linkedtransferqueue和synchronousqueue区别"}},[a._v("#")]),a._v(" LinkedTransferQueue和SynchronousQueue区别")]),a._v(" "),r("h3",{attrs:{id:"concurrentskiplistmap跳表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrentskiplistmap跳表"}},[a._v("#")]),a._v(" ConcurrentSkipListMap跳表")]),a._v(" "),r("h3",{attrs:{id:"阻塞队列的有界和无界"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列的有界和无界"}},[a._v("#")]),a._v(" 阻塞队列的有界和无界")]),a._v(" "),r("h3",{attrs:{id:"bio、nio、aio"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bio、nio、aio"}},[a._v("#")]),a._v(" BIO、NIO、AIO")]),a._v(" "),r("h3",{attrs:{id:"final关键字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#final关键字"}},[a._v("#")]),a._v(" final关键字")]),a._v(" "),r("h3",{attrs:{id:"volatile关键字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#volatile关键字"}},[a._v("#")]),a._v(" volatile关键字")]),a._v(" "),r("h3",{attrs:{id:"tomcat为什么要重写类加载器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tomcat为什么要重写类加载器"}},[a._v("#")]),a._v(" Tomcat为什么要重写类加载器")]),a._v(" "),r("ul",[r("li",[r("strong",[a._v("无法实现隔离性")])]),a._v(" "),r("li",[r("strong",[a._v("无法实现热替换")])]),a._v(" "),r("li",[r("strong",[a._v("如何打破双亲委派模型")])])]),a._v(" "),r("h2",{attrs:{id:"jvm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[a._v("#")]),a._v(" JVM")]),a._v(" "),r("h3",{attrs:{id:"堆空间为什么要分代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆空间为什么要分代"}},[a._v("#")]),a._v(" 堆空间为什么要分代")]),a._v(" "),r("h3",{attrs:{id:"gc安全点和安全区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc安全点和安全区域"}},[a._v("#")]),a._v(" GC安全点和安全区域")]),a._v(" "),r("h3",{attrs:{id:"垃圾回收触发时机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收触发时机"}},[a._v("#")]),a._v(" 垃圾回收触发时机")]),a._v(" "),r("ul",[r("li",[a._v("Minor GC")]),a._v(" "),r("li",[a._v("Major GC")]),a._v(" "),r("li",[a._v("Full GC")])]),a._v(" "),r("h3",{attrs:{id:"类加载过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[a._v("#")]),a._v(" 类加载过程")]),a._v(" "),r("h3",{attrs:{id:"垃圾回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),r("h5",{attrs:{id:"对象生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象生命周期"}},[a._v("#")]),a._v(" 对象生命周期")]),a._v(" "),r("h5",{attrs:{id:"垃圾回收算法-标记清除、标记复制、标记清除整理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法-标记清除、标记复制、标记清除整理"}},[a._v("#")]),a._v(" 垃圾回收算法(标记清除、标记复制、标记清除整理)")]),a._v(" "),r("h5",{attrs:{id:"垃圾回收器-parallel、cms、g1等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器-parallel、cms、g1等"}},[a._v("#")]),a._v(" 垃圾回收器(Parallel、CMS、G1等)")]),a._v(" "),r("h5",{attrs:{id:"垃圾回收过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收过程"}},[a._v("#")]),a._v(" 垃圾回收过程")]),a._v(" "),r("h3",{attrs:{id:"方法区演进-分jdk版本"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区演进-分jdk版本"}},[a._v("#")]),a._v(" 方法区演进(分JDK版本)")]),a._v(" "),r("h3",{attrs:{id:"虚拟机栈的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈的理解"}},[a._v("#")]),a._v(" 虚拟机栈的理解")]),a._v(" "),r("h3",{attrs:{id:"栈帧原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈帧原理"}},[a._v("#")]),a._v(" 栈帧原理")]),a._v(" "),r("h3",{attrs:{id:"栈帧组成结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈帧组成结构"}},[a._v("#")]),a._v(" 栈帧组成结构")]),a._v(" "),r("h3",{attrs:{id:"对象怎么定位-句柄访问、-hotspot-直接指针"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象怎么定位-句柄访问、-hotspot-直接指针"}},[a._v("#")]),a._v(" 对象怎么定位(句柄访问、(HotSpot)直接指针)")]),a._v(" "),r("h3",{attrs:{id:"unsafe类介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#unsafe类介绍"}},[a._v("#")]),a._v(" Unsafe类介绍")]),a._v(" "),r("h3",{attrs:{id:"逃逸分析的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析的作用"}},[a._v("#")]),a._v(" 逃逸分析的作用")]),a._v(" "),r("h3",{attrs:{id:"cglib和jdk动态代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cglib和jdk动态代理"}},[a._v("#")]),a._v(" cglib和JDK动态代理")]),a._v(" "),r("h3",{attrs:{id:"动态代理实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态代理实现原理"}},[a._v("#")]),a._v(" 动态代理实现原理")]),a._v(" "),r("h3",{attrs:{id:"java的tlab-thread-local-allocation-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java的tlab-thread-local-allocation-buffer"}},[a._v("#")]),a._v(" Java的TLAB(Thread Local Allocation Buffer)")]),a._v(" "),r("h3",{attrs:{id:"oom异常排查方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#oom异常排查方式"}},[a._v("#")]),a._v(" OOM异常排查方式")]),a._v(" "),r("h2",{attrs:{id:"juc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#juc"}},[a._v("#")]),a._v(" JUC")]),a._v(" "),r("h3",{attrs:{id:"java创建线程方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java创建线程方式"}},[a._v("#")]),a._v(" Java创建线程方式")]),a._v(" "),r("h3",{attrs:{id:"线程池核心参数、创建方式、拒绝策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程池核心参数、创建方式、拒绝策略"}},[a._v("#")]),a._v(" 线程池核心参数、创建方式、拒绝策略")]),a._v(" "),r("h3",{attrs:{id:"线程各状态生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程各状态生命周期"}},[a._v("#")]),a._v(" 线程各状态生命周期")]),a._v(" "),r("h3",{attrs:{id:"线程池复用原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程池复用原理"}},[a._v("#")]),a._v(" 线程池复用原理")]),a._v(" "),r("h3",{attrs:{id:"synchronized和lock锁区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronized和lock锁区别"}},[a._v("#")]),a._v(" Synchronized和Lock锁区别")]),a._v(" "),r("h3",{attrs:{id:"countdownlatch和cyclicbarrier"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch和cyclicbarrier"}},[a._v("#")]),a._v(" CountDownLatch和CyclicBarrier")]),a._v(" "),r("h3",{attrs:{id:"reentrantlock源码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock源码"}},[a._v("#")]),a._v(" ReentrantLock源码")]),a._v(" "),r("h2",{attrs:{id:"redis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[a._v("#")]),a._v(" Redis")]),a._v(" "),r("h3",{attrs:{id:"redis单线程为什么这么快"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis单线程为什么这么快"}},[a._v("#")]),a._v(" Redis单线程为什么这么快")]),a._v(" "),r("h3",{attrs:{id:"redis的aof和rdb策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的aof和rdb策略"}},[a._v("#")]),a._v(" Redis的AOF和RDB策略")]),a._v(" "),r("h3",{attrs:{id:"redis为何使用pipeline"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis为何使用pipeline"}},[a._v("#")]),a._v(" Redis为何使用Pipeline")]),a._v(" "),r("h3",{attrs:{id:"redis主从同步过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis主从同步过程"}},[a._v("#")]),a._v(" Redis主从同步过程")]),a._v(" "),r("h2",{attrs:{id:"mysql"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[a._v("#")]),a._v(" MySQL")]),a._v(" "),r("h3",{attrs:{id:"mysql-行锁、页锁、表锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql-行锁、页锁、表锁"}},[a._v("#")]),a._v(" MySQL 行锁、页锁、表锁")]),a._v(" "),r("h3",{attrs:{id:"死锁原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#死锁原理"}},[a._v("#")]),a._v(" 死锁原理")]),a._v(" "),r("ul",[r("li",[a._v("MVCC")]),a._v(" "),r("li",[a._v("2PL")]),a._v(" "),r("li",[a._v("为何发生死锁")])]),a._v(" "),r("h3",{attrs:{id:"mysql原子性-undo-log-和持久性-redo-log-如何保证的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql原子性-undo-log-和持久性-redo-log-如何保证的"}},[a._v("#")]),a._v(" MySQL原子性(undo log)和持久性(redo log)如何保证的")]),a._v(" "),r("h3",{attrs:{id:"innodb行级锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#innodb行级锁"}},[a._v("#")]),a._v(" InnoDB行级锁")]),a._v(" "),r("h3",{attrs:{id:"innodb和myisam区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#innodb和myisam区别"}},[a._v("#")]),a._v(" InnoDB和MyISAM区别")]),a._v(" "),r("h3",{attrs:{id:"mysql的聚簇索引和非聚簇索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql的聚簇索引和非聚簇索引"}},[a._v("#")]),a._v(" MySQL的聚簇索引和非聚簇索引")]),a._v(" "),r("h3",{attrs:{id:"mysql如何解决超大分页"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql如何解决超大分页"}},[a._v("#")]),a._v(" MySQL如何解决超大分页")]),a._v(" "),r("ul",[r("li",[a._v("ID连续优化")]),a._v(" "),r("li",[a._v("索引覆盖优化")])]),a._v(" "),r("h3",{attrs:{id:"mysql回表操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql回表操作"}},[a._v("#")]),a._v(" MySQL回表操作")]),a._v(" "),r("h3",{attrs:{id:"索引覆盖和索引下推"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#索引覆盖和索引下推"}},[a._v("#")]),a._v(" 索引覆盖和索引下推")]),a._v(" "),r("h3",{attrs:{id:"消息队列mq"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息队列mq"}},[a._v("#")]),a._v(" 消息队列MQ")]),a._v(" "),r("h3",{attrs:{id:"如何保证rabbitmq高可用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq高可用"}},[a._v("#")]),a._v(" 如何保证RabbitMQ高可用")]),a._v(" "),r("h3",{attrs:{id:"如何保证rabbitmq消息可靠性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq消息可靠性"}},[a._v("#")]),a._v(" 如何保证RabbitMQ消息可靠性")]),a._v(" "),r("h3",{attrs:{id:"如何解决rabbitmq消息堆积"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何解决rabbitmq消息堆积"}},[a._v("#")]),a._v(" 如何解决RabbitMQ消息堆积")]),a._v(" "),r("h3",{attrs:{id:"如何保证rabbitmq消息幂等性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何保证rabbitmq消息幂等性"}},[a._v("#")]),a._v(" 如何保证RabbitMQ消息幂等性")]),a._v(" "),r("h2",{attrs:{id:"mybatis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mybatis"}},[a._v("#")]),a._v(" MyBatis")]),a._v(" "),r("h3",{attrs:{id:"mybatis如何支持延迟加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mybatis如何支持延迟加载"}},[a._v("#")]),a._v(" MyBatis如何支持延迟加载")]),a._v(" "),r("h3",{attrs:{id:"mybatis缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mybatis缓存"}},[a._v("#")]),a._v(" Mybatis缓存")]),a._v(" "),r("h2",{attrs:{id:"spring"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[a._v("#")]),a._v(" Spring")]),a._v(" "),r("h3",{attrs:{id:"spring三级缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring三级缓存"}},[a._v("#")]),a._v(" Spring三级缓存")]),a._v(" "),r("h3",{attrs:{id:"spring-bean生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean生命周期"}},[a._v("#")]),a._v(" Spring Bean生命周期")]),a._v(" "),r("h3",{attrs:{id:"spring-bean的作用域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean的作用域"}},[a._v("#")]),a._v(" Spring Bean的作用域")]),a._v(" "),r("h3",{attrs:{id:"spring-aop和ioc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop和ioc"}},[a._v("#")]),a._v(" Spring AOP和IOC")]),a._v(" "),r("h3",{attrs:{id:"springbootapplication注解作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#springbootapplication注解作用"}},[a._v("#")]),a._v(" @SpringBootApplication注解作用")]),a._v(" "),r("ul",[r("li",[a._v("@SpringBootConfiguration")]),a._v(" "),r("li",[a._v("@EnableAutoConfiguration")]),a._v(" "),r("li",[a._v("@ComponentScan")])]),a._v(" "),r("h2",{attrs:{id:"分布式架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式架构"}},[a._v("#")]),a._v(" 分布式架构")]),a._v(" "),r("h3",{attrs:{id:"单体架构、垂直架构、面向服务架构soa、微服务架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单体架构、垂直架构、面向服务架构soa、微服务架构"}},[a._v("#")]),a._v(" 单体架构、垂直架构、面向服务架构SOA、微服务架构")]),a._v(" "),r("h3",{attrs:{id:"分布式事务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),r("h3",{attrs:{id:"分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[a._v("#")]),a._v(" 分布式锁")]),a._v(" "),r("h3",{attrs:{id:"skywalking核心组件-分布式链路追踪"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#skywalking核心组件-分布式链路追踪"}},[a._v("#")]),a._v(" SkyWalking核心组件(分布式链路追踪)")]),a._v(" "),r("ul",[r("li",[a._v("Agent探针 采集服务信息trace grpc上报")]),a._v(" "),r("li",[a._v("OAP 收集信息、响应UI请求")]),a._v(" "),r("li",[a._v("UI")])]),a._v(" "),r("h3",{attrs:{id:"配置中心-nacos、apollo、springcloud-config-差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#配置中心-nacos、apollo、springcloud-config-差异"}},[a._v("#")]),a._v(" 配置中心(nacos、apollo、SpringCloud Config)差异")]),a._v(" "),r("h2",{attrs:{id:"zookeeper"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[a._v("#")]),a._v(" Zookeeper")]),a._v(" "),r("h3",{attrs:{id:"zookeeper如何解决脑裂问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper如何解决脑裂问题"}},[a._v("#")]),a._v(" Zookeeper如何解决脑裂问题")]),a._v(" "),r("ul",[r("li",[a._v("假死")]),a._v(" "),r("li",[a._v("脑裂")]),a._v(" "),r("li",[a._v("心跳")])]),a._v(" "),r("h2",{attrs:{id:"dubbo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo"}},[a._v("#")]),a._v(" Dubbo")]),a._v(" "),r("h3",{attrs:{id:"dubbo-rpc调用过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-rpc调用过程"}},[a._v("#")]),a._v(" Dubbo RPC调用过程")]),a._v(" "),r("h3",{attrs:{id:"dubbo-spi机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo-spi机制"}},[a._v("#")]),a._v(" Dubbo SPI机制")]),a._v(" "),r("h3",{attrs:{id:"dubbo动态代理javassist和jdk区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo动态代理javassist和jdk区别"}},[a._v("#")]),a._v(" Dubbo动态代理javassist和jdk区别")]),a._v(" "),r("h3",{attrs:{id:"dubbo服务本地缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo服务本地缓存"}},[a._v("#")]),a._v(" Dubbo服务本地缓存")]),a._v(" "),r("h3",{attrs:{id:"dubbo服务治理、服务发现、服务优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo服务治理、服务发现、服务优化"}},[a._v("#")]),a._v(" Dubbo服务治理、服务发现、服务优化")]),a._v(" "),r("h3",{attrs:{id:"dubbo中负载策略、熔断策略、集群方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dubbo中负载策略、熔断策略、集群方式"}},[a._v("#")]),a._v(" Dubbo中负载策略、熔断策略、集群方式")]),a._v(" "),r("h2",{attrs:{id:"特殊场景解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特殊场景解决方案"}},[a._v("#")]),a._v(" 特殊场景解决方案")]),a._v(" "),r("h3",{attrs:{id:"解决流量激增问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解决流量激增问题"}},[a._v("#")]),a._v(" 解决流量激增问题")]),a._v(" "),r("ul",[r("li",[a._v("数据预处理")]),a._v(" "),r("li",[a._v("Dubbo异步编程")]),a._v(" "),r("li",[a._v("并发处理(redis单线程+自增数值) 提前将id分发到各个broker")]),a._v(" "),r("li",[a._v("redis集合set,存储商品ID和用户ID")]),a._v(" "),r("li",[a._v("单用户IP的qps")]),a._v(" "),r("li",[a._v("DNS")])]),a._v(" "),r("h3",{attrs:{id:"接口耗时性能调优"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口耗时性能调优"}},[a._v("#")]),a._v(" 接口耗时性能调优")]),a._v(" "),r("ul",[r("li",[a._v("减少非必要循环")]),a._v(" "),r("li",[a._v("DB中SQL调优")]),a._v(" "),r("li",[a._v("连接池调优")]),a._v(" "),r("li",[a._v("串行换并行异步")]),a._v(" "),r("li",[a._v("缓存(本地缓存Map/ConcurrentHashMap、Guava Cache、Redis)")]),a._v(" "),r("li",[a._v("NoSQL")]),a._v(" "),r("li",[a._v("异步(MQ、异步编程、阻塞队列)")]),a._v(" "),r("li",[a._v("JVM调优(gc、full gc、old cms gc)")])])])}),[],!1,null,null,null);t.default=e.exports}}]);